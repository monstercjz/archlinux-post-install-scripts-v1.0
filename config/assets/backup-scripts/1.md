## 1.2.2_zh_cleanup_fix
```bash
#!/usr/bin/env bash

# arch_backup.sh - 高级 Arch Linux 系统备份脚本
# -----------------------------------------------------------------------------
# 版本 (Version):         1.2.2_zh_cleanup_fix
# 最后更新 (Last Updated): 2025-06-16 # 请替换为实际日期
# 作者 (Author):          AI (由 cjz 协助测试和反馈)
# 联系 (Contact):         <您的邮箱或项目地址，可选>
# 许可证 (License):       MIT
# -----------------------------------------------------------------------------
# 描述 (Description):
#   一个用于 Arch Linux 系统的全面备份工具，支持系统配置、用户数据、
#   软件包列表、系统日志和自定义路径的备份。特性包括增量备份、
#   压缩、旧备份清理、并行处理和详细日志记录。
#   建议使用 'sudo ./arch_backup.sh' 运行以获得完整功能。
#
# 运行需求 (Requirements):
#   - Bash 4.0+
#   - rsync, tar, coreutils (find, sort, df, cut, head, tail, sed, grep, wc, mkdir, rm, id, date, basename, dirname, mktemp, du, awk)
#   - 压缩工具 (根据配置: gzip, bzip2, or xz)
#   - GNU Parallel (可选, 用于并行备份 CONF_PARALLEL_JOBS > 1)
#
# 配置 (Configuration):
#   配置文件应位于以下任一路径 (按优先级):
#   1. ${HOME}/.config/arch_backup.conf (如果CONF_TARGET_USERNAME未指定，则为执行sudo的用户的HOME)
#   2. /etc/arch_backup.conf
#   可以在配置文件中设置 CONF_TARGET_USERNAME 来指定要备份家目录的特定用户。
# -----------------------------------------------------------------------------
# 更新日志 (Changelog):
#   1.2.2 (2025-06-16):
#     - 修正 cleanup_backups 函数中处理未压缩快照的逻辑，确保在压缩包已存在或压缩功能禁用时能正确提议删除原快照。
#     - 改进 cleanup_backups 中打印待删除压缩归档列表的方式，使用 mapfile 提高稳健性。
#   1.2.1 (2025-06-16):
#     - 修复 load_config 中 EFFECTIVE_GID 未定义导致的 "未绑定的变量" 错误。
#   1.2.0 (2025-06-16):
#     - 新增 CONF_TARGET_USERNAME 配置项，允许指定备份家目录的目标用户。
#     - 改进原始用户信息获取逻辑，优先使用 CONF_TARGET_USERNAME。
#     - 为主要函数添加了符合 ShellDoc/BashDoc 风格的详细注释。
#     - 强调脚本应通过 sudo 运行。
#   1.1.1 (2025-06-15):
#     - 修复 backup_packages 中统计包数量日志的 "错误的替换" 问题。
#     - 修复 compress_and_verify_backup 中压缩包校验命令的执行方式。
#     - 增强 run_backup 中对 --link-dest 上一个快照存在性的检查。
#     - 恢复并加固 check_dependencies 中的版本获取逻辑。
#   (更早版本日志省略)
# -----------------------------------------------------------------------------

# 严格模式
set -euo pipefail
IFS=$'\n\t'

# === 脚本信息 ===
SCRIPT_VERSION="1.2.2_zh_cleanup_fix"
SCRIPT_NAME=$(basename "$0")
SCRIPT_DIR=$(cd "$(dirname "$0")" && pwd)
SCRIPT_PID=$$

# === 全局变量 (默认值, 会被配置文件覆盖) ===
CONF_BACKUP_ROOT_DIR=""
CONF_LOG_FILE="/tmp/${SCRIPT_NAME}.log"
CONF_LOG_LEVEL="INFO" # DEBUG, INFO, WARN, ERROR
CONF_TARGET_USERNAME="" # 新增：指定要备份家目录的用户名

CONF_BACKUP_SYSTEM_CONFIG="true"
CONF_BACKUP_USER_DATA="true"
CONF_BACKUP_PACKAGES="true"
CONF_BACKUP_LOGS="true"
CONF_BACKUP_CUSTOM_PATHS="true"

CONF_USER_HOME_INCLUDE=(".config" ".local/share" ".ssh" ".gnupg" ".bashrc")
CONF_USER_HOME_EXCLUDE=("*/.cache/*" "*/Cache/*")

CONF_CUSTOM_PATHS_INCLUDE=()
CONF_CUSTOM_PATHS_EXCLUDE=()

CONF_SYSTEM_LOG_FILES=("pacman.log" "Xorg.0.log")
CONF_BACKUP_JOURNALCTL="true"
CONF_JOURNALCTL_ARGS=""

CONF_INCREMENTAL_BACKUP="true"
CONF_COMPRESSION_ENABLE="true"
CONF_COMPRESSION_METHOD="xz"
CONF_COMPRESSION_LEVEL="6"
CONF_COMPRESSION_EXT="tar.xz"

CONF_RETENTION_UNCOMPRESSED_COUNT="3"
CONF_RETENTION_COMPRESSED_COUNT="10"
CONF_RETENTION_COMPRESSED_DAYS="90"

CONF_PARALLEL_JOBS="1"
CONF_PROMPT_FOR_CONFIRMATION="true"
CONF_MIN_FREE_DISK_SPACE_PERCENT="10"

# 运行时变量
LOADED_CONFIG_FILE=""
CURRENT_TIMESTAMP=""
BACKUP_TARGET_DIR_UNCOMPRESSED=""
BACKUP_TARGET_DIR_COMPRESSED_ARCHIVES=""

EFFECTIVE_UID=$(id -u)
EFFECTIVE_USER=$(id -un)
EFFECTIVE_GID=$(id -g) # <--- 添加此行来定义 EFFECTIVE_GID
# 这些变量将由 get_original_user_info 函数设置
TARGET_BACKUP_USER=""      # 最终决定备份其家目录的用户名
TARGET_BACKUP_UID=""       # 该用户的 UID
TARGET_BACKUP_GID=""       # 该用户的 GID
TARGET_BACKUP_HOME=""      # 该用户的家目录

PARALLEL_CMD=""

LOG_LEVEL_DEBUG=0
LOG_LEVEL_INFO=1
LOG_LEVEL_WARN=2
LOG_LEVEL_ERROR=3
declare -A LOG_LEVEL_NAMES=([0]="DEBUG" [1]="INFO" [2]="WARN" [3]="ERROR")
CURRENT_LOG_LEVEL=${LOG_LEVEL_INFO}

COLOR_RESET='\033[0m'
COLOR_RED='\033[0;31m'
COLOR_GREEN='\033[0;32m'
COLOR_YELLOW='\033[0;33m'
COLOR_BLUE='\033[0;34m'
COLOR_CYAN='\033[0;36m'

# === 辅助函数 ===

################################################################################
# 记录日志消息到终端和日志文件。
# Globals:
#   CONF_LOG_FILE       日志文件路径。
#   CURRENT_LOG_LEVEL   当前脚本的日志级别阈值。
#   LOG_LEVEL_NAMES     日志级别名称映射数组。
#   COLOR_*             终端颜色代码。
# Arguments:
#   $1 - 日志级别字符串 (e.g., "INFO", "ERROR").
#   $2 - 要记录的日志消息.
# Returns:
#   None
################################################################################
log_msg() {
    local level_name="$1"
    local message="$2"
    local level_num

    case "$level_name" in
        DEBUG) level_num=$LOG_LEVEL_DEBUG ;;
        INFO)  level_num=$LOG_LEVEL_INFO  ;;
        WARN)  level_num=$LOG_LEVEL_WARN  ;;
        ERROR) level_num=$LOG_LEVEL_ERROR ;;
        *)     level_num=$LOG_LEVEL_INFO; message="[无效日志级别] $message" ;;
    esac

    if [[ "$level_num" -ge "$CURRENT_LOG_LEVEL" ]]; then
        local color="$COLOR_RESET"
        [[ "$level_name" == "ERROR" ]] && color="$COLOR_RED"
        [[ "$level_name" == "WARN" ]]  && color="$COLOR_YELLOW"
        [[ "$level_name" == "INFO" ]]  && color="$COLOR_GREEN"
        [[ "$level_name" == "DEBUG" ]] && color="$COLOR_CYAN"
        echo -e "$(date '+%Y-%m-%d %H:%M:%S') [${color}${level_name}${COLOR_RESET}] $message" | tee -a "$CONF_LOG_FILE"
    elif [[ "$level_name" == "ERROR" || "$level_name" == "WARN" ]]; then # 确保重要信息总是写入日志文件
        echo -e "$(date '+%Y-%m-%d %H:%M:%S') [${level_name}] $message" >> "$CONF_LOG_FILE"
    fi
}

################################################################################
# 向用户显示一个确认提示。
# Globals:
#   CONF_PROMPT_FOR_CONFIRMATION  如果为 "true"，则提示用户；否则自动确认。
# Arguments:
#   $1 - 显示给用户的提示消息。
# Returns:
#   0 (true) 如果用户确认 (yes) 或自动确认。
#   1 (false) 如果用户拒绝 (no)。
################################################################################
confirm_action() {
    local prompt_message="$1"
    if [[ "$CONF_PROMPT_FOR_CONFIRMATION" != "true" ]]; then
        log_msg INFO "由于CONF_PROMPT_FOR_CONFIRMATION=false，自动确认操作: $prompt_message"
        return 0
    fi
    while true; do
        read -r -p "$prompt_message [y/N]: " response
        case "$response" in
            [yY][eE][sS]|[yY]) return 0 ;;
            [nN][oO]|[nN]|"") return 1 ;;
            *) echo "请输入 yes (y) 或 no (n)。" ;;
        esac
    done
}

################################################################################
# 检查脚本运行所需的依赖工具是否已安装。
# Globals:
#   None
# Arguments:
#   $@ - 需要检查的依赖工具名称列表。
# Returns:
#   0 如果所有依赖都存在。
#   脚本会以状态码 1 退出，如果任何依赖缺失。
################################################################################
check_dependencies() {
    # set -x # 调试时取消注释此行
    local missing_deps=0
    log_msg INFO "开始检查依赖工具..."
    for dep in "$@"; do
        if ! command -v "$dep" &>/dev/null; then
            log_msg ERROR "必需的依赖工具 '$dep' 未安装。"
            missing_deps=1
        else
            local version_info_raw=""
            local version_info_display=""
            case "$dep" in
                rsync)    version_info_raw=$((rsync --version | head -n1) 2>/dev/null || true) ;;
                tar)      version_info_raw=$((tar --version | head -n1) 2>/dev/null || true) ;;
                xz)       version_info_raw=$((xz --version | head -n1) 2>/dev/null || true) ;;
                gzip)     version_info_raw=$((gzip --version | head -n1) 2>/dev/null || true) ;;
                bzip2)    version_info_raw=$((bzip2 --help 2>&1 | grep "bzip2,.*Version") 2>/dev/null || true) ;;
                parallel) version_info_raw=$((parallel --version | head -n1) 2>/dev/null || true) ;;
                awk)      version_info_raw=$((awk --version | head -n1) 2>/dev/null || true) ;;
                *)        version_info_raw="" ;;
            esac
            if [[ -n "$version_info_raw" ]]; then
                version_info_cleaned=$(echo "$version_info_raw" | LC_ALL=C tr -dc '[:alnum:][:punct:][:space:]')
            else
                version_info_cleaned=""
            fi
            if [[ -n "$version_info_cleaned" ]]; then
                version_info_display="$version_info_cleaned"
                log_msg DEBUG "依赖 '$dep' 已找到。版本信息: $version_info_display"
            else
                log_msg DEBUG "依赖 '$dep' 已找到。(版本信息获取失败、为空或未尝试)"
            fi
        fi
    done
    if [[ "$missing_deps" -eq 1 ]]; then
        log_msg ERROR "请安装缺失的依赖项后重试。"
        log_msg INFO "在 Arch Linux 上, 通常可以使用以下命令安装: sudo pacman -S <软件包名称>"
        # set +x # 如果开启了xtrace，在这里关闭
        exit 1
    fi
    log_msg INFO "所有核心依赖项检查完毕。"
    # set +x # 如果开启了xtrace，在这里关闭
}

################################################################################
# 获取并设置用于备份家目录的目标用户的信息 (用户名, UID, GID, 家目录路径)。
# 优先使用 CONF_TARGET_USERNAME 配置项。如果未配置，则尝试使用 SUDO_USER
# (如果脚本通过 sudo 执行且 SUDO_USER 不是 root)。
# 如果两者都不可用或无效，则 TARGET_BACKUP_* 变量可能为空，
# 后续的用户数据备份任务将跳过。
# Globals:
#   CONF_TARGET_USERNAME (R)  配置文件中指定的目标用户名。
#   SUDO_USER            (R)  环境变量，表示原始 sudo 用户。
#   USER                 (R)  环境变量，表示当前用户。
#   HOME                 (R)  环境变量，表示当前用户的家目录。
#   TARGET_BACKUP_USER   (W)  设置目标用户名。
#   TARGET_BACKUP_UID    (W)  设置目标用户的 UID。
#   TARGET_BACKUP_GID    (W)  设置目标用户的 GID。
#   TARGET_BACKUP_HOME   (W)  设置目标用户的家目录。
# Arguments:
#   None
# Returns:
#   None. 直接修改全局变量。
################################################################################
get_target_backup_user_info() {
    local user_to_query=""

    if [[ -n "$CONF_TARGET_USERNAME" ]]; then
        log_msg INFO "配置文件中指定了目标用户: '$CONF_TARGET_USERNAME'。"
        user_to_query="$CONF_TARGET_USERNAME"
    elif [[ -n "$SUDO_USER" && "$SUDO_USER" != "root" ]]; then
        log_msg INFO "脚本通过 sudo 执行，尝试使用原始用户 '$SUDO_USER' 作为备份目标。"
        user_to_query="$SUDO_USER"
    elif [[ "$EFFECTIVE_USER" != "root" ]]; then # 非 sudo，且当前用户不是 root
        log_msg INFO "脚本以普通用户 '$EFFECTIVE_USER' 执行，将尝试备份此用户的家目录。"
        user_to_query="$EFFECTIVE_USER"
    else # 直接以 root 运行，且未指定 CONF_TARGET_USERNAME
        log_msg WARN "脚本以 root 身份运行，且未在配置中指定 CONF_TARGET_USERNAME。将不进行特定用户的家目录备份，除非手动配置了包含root家目录的自定义路径。"
        TARGET_BACKUP_USER=""
        TARGET_BACKUP_UID=""
        TARGET_BACKUP_GID=""
        TARGET_BACKUP_HOME=""
        return
    fi

    if ! id -u "$user_to_query" >/dev/null 2>&1; then
        log_msg ERROR "无法找到用户 '$user_to_query' 的信息。请检查用户名是否正确或用户是否存在。"
        TARGET_BACKUP_USER=""
        TARGET_BACKUP_UID=""
        TARGET_BACKUP_GID=""
        TARGET_BACKUP_HOME=""
        # 可以选择在这里 exit 1，或者让用户数据备份任务优雅地跳过
        return # 暂时不退出，让脚本继续尝试其他备份任务
    fi

    TARGET_BACKUP_USER="$user_to_query"
    TARGET_BACKUP_UID=$(id -u "$user_to_query")
    TARGET_BACKUP_GID=$(id -g "$user_to_query")
    TARGET_BACKUP_HOME=$(getent passwd "$user_to_query" | cut -d: -f6)

    if [[ -z "$TARGET_BACKUP_HOME" || ! -d "$TARGET_BACKUP_HOME" ]]; then
        log_msg ERROR "无法获取或访问用户 '$TARGET_BACKUP_USER' 的家目录 ('$TARGET_BACKUP_HOME')。"
        # 清空信息，后续备份任务会跳过
        TARGET_BACKUP_USER=""
        TARGET_BACKUP_UID=""
        TARGET_BACKUP_GID=""
        TARGET_BACKUP_HOME=""
    else
        log_msg INFO "目标备份用户信息: User='$TARGET_BACKUP_USER', UID='$TARGET_BACKUP_UID', GID='$TARGET_BACKUP_GID', Home='$TARGET_BACKUP_HOME'"
    fi
}

################################################################################
# 加载脚本配置文件。
# 会依次尝试多个预定义的配置文件路径。
# Globals:
#   (许多 CONF_* 变量会被此函数从配置文件中设置)
#   LOADED_CONFIG_FILE (W)  记录实际加载的配置文件路径。
#   CONF_LOG_FILE      (R/W) 日志文件路径。
#   CONF_LOG_LEVEL     (R/W) 日志级别。
#   TARGET_BACKUP_HOME (R)  用于确定用户特定的配置文件路径。
#   SCRIPT_NAME        (R)  用于构建默认配置文件名。
#   PARALLEL_CMD       (W)  设置并行执行命令。
# Arguments:
#   None
# Returns:
#   None. 脚本会因关键配置缺失或无法创建日志而退出。
################################################################################
load_config() {
    log_msg INFO "开始加载配置文件..."
    get_target_backup_user_info

    local config_file_search_paths=()
    if [[ -n "$TARGET_BACKUP_HOME" && -d "$TARGET_BACKUP_HOME" ]]; then
        config_file_search_paths+=(
            "${TARGET_BACKUP_HOME}/.config/$(basename "$SCRIPT_NAME" .sh).conf"
            "${TARGET_BACKUP_HOME}/.config/arch_backup.conf"
        )
    fi
    if [[ -n "$SUDO_USER" && "$SUDO_USER" != "root" ]]; then
        local sudo_user_home
        sudo_user_home=$(getent passwd "$SUDO_USER" | cut -d: -f6)
        if [[ -n "$sudo_user_home" && -d "$sudo_user_home" && "$sudo_user_home" != "$TARGET_BACKUP_HOME" ]]; then
            config_file_search_paths+=(
                "${sudo_user_home}/.config/$(basename "$SCRIPT_NAME" .sh).conf"
                "${sudo_user_home}/.config/arch_backup.conf"
            )
        fi
    fi
    config_file_search_paths+=(
        "/etc/$(basename "$SCRIPT_NAME" .sh).conf"
        "/etc/arch_backup.conf"
    )
    config_file_paths=($(printf "%s\n" "${config_file_search_paths[@]}" | sort -u | grep -v '^$'))

    for cf_path in "${config_file_paths[@]}"; do
        if [[ -f "$cf_path" ]]; then
            log_msg INFO "找到配置文件: $cf_path"
            # shellcheck source=/dev/null
            source "$cf_path"
            LOADED_CONFIG_FILE="$cf_path"
            log_msg INFO "成功加载配置文件: $LOADED_CONFIG_FILE"
            get_target_backup_user_info # Re-evaluate target user if CONF_TARGET_USERNAME was in config
            break
        fi
    done
    if [[ -z "$LOADED_CONFIG_FILE" ]]; then
        log_msg WARN "未找到配置文件，将使用默认设置。搜索路径:"
        for cf_path in "${config_file_paths[@]}"; do log_msg WARN "  - $cf_path"; done
        # get_target_backup_user_info has already been called once if no config file found
    fi

    case "${CONF_LOG_LEVEL^^}" in
        DEBUG) CURRENT_LOG_LEVEL=$LOG_LEVEL_DEBUG ;; INFO) CURRENT_LOG_LEVEL=$LOG_LEVEL_INFO  ;;
        WARN)  CURRENT_LOG_LEVEL=$LOG_LEVEL_WARN  ;; ERROR) CURRENT_LOG_LEVEL=$LOG_LEVEL_ERROR ;;
        *) log_msg WARN "无效的 CONF_LOG_LEVEL '${CONF_LOG_LEVEL}'. 将使用默认级别 INFO."; CURRENT_LOG_LEVEL=$LOG_LEVEL_INFO ;;
    esac

    local log_owner_uid="$EFFECTIVE_UID"
    local log_owner_gid="$EFFECTIVE_GID"
    if [[ -n "$TARGET_BACKUP_USER" && "$TARGET_BACKUP_UID" != "0" ]]; then
        log_owner_uid="$TARGET_BACKUP_UID"
        log_owner_gid="$TARGET_BACKUP_GID"
    elif [[ -n "$SUDO_USER" && "$(id -u "$SUDO_USER" 2>/dev/null)" != "0" && "$(id -u "$SUDO_USER" 2>/dev/null)" != "" ]]; then
        if id -u "$SUDO_USER" >/dev/null 2>&1; then
           log_owner_uid=$(id -u "$SUDO_USER")
           log_owner_gid=$(id -g "$SUDO_USER")
        fi
    fi

    local log_dir; log_dir=$(dirname "$CONF_LOG_FILE")
    if [[ ! -d "$log_dir" ]]; then
        mkdir -p "$log_dir" || { log_msg ERROR "无法创建日志目录: $log_dir"; exit 1; }
        if [[ "$EFFECTIVE_UID" -eq 0 ]]; then
            chown "$log_owner_uid:$log_owner_gid" "$log_dir" || log_msg WARN "无法更改日志目录 '$log_dir' 的所有权为 UID:$log_owner_uid GID:$log_owner_gid."
        fi
    fi
    touch "$CONF_LOG_FILE" || { log_msg ERROR "无法创建或访问日志文件: $CONF_LOG_FILE"; exit 1; }
    if [[ "$EFFECTIVE_UID" -eq 0 ]]; then
         chown "$log_owner_uid:$log_owner_gid" "$CONF_LOG_FILE" || log_msg WARN "无法更改日志文件 '$CONF_LOG_FILE' 的所有权为 UID:$log_owner_uid GID:$log_owner_gid."
    fi

    if [[ -z "$CONF_BACKUP_ROOT_DIR" ]]; then
        log_msg ERROR "CONF_BACKUP_ROOT_DIR 未在配置文件中设置或为空。请配置此项。"
        exit 1
    fi
    mkdir -p "$CONF_BACKUP_ROOT_DIR" || { log_msg ERROR "无法创建备份根目录: $CONF_BACKUP_ROOT_DIR"; exit 1; }
    BACKUP_TARGET_DIR_UNCOMPRESSED="${CONF_BACKUP_ROOT_DIR}/snapshots"
    BACKUP_TARGET_DIR_COMPRESSED_ARCHIVES="${CONF_BACKUP_ROOT_DIR}/archives"
    mkdir -p "$BACKUP_TARGET_DIR_UNCOMPRESSED" || { log_msg ERROR "无法创建快照目录: $BACKUP_TARGET_DIR_UNCOMPRESSED"; exit 1; }
    mkdir -p "$BACKUP_TARGET_DIR_COMPRESSED_ARCHIVES" || { log_msg ERROR "无法创建归档目录: $BACKUP_TARGET_DIR_COMPRESSED_ARCHIVES"; exit 1; }

    case "$CONF_COMPRESSION_METHOD" in
        gzip) CONF_COMPRESSION_EXT="tar.gz" ;; bzip2) CONF_COMPRESSION_EXT="tar.bz2" ;;
        xz) CONF_COMPRESSION_EXT="tar.xz" ;;
        *) log_msg WARN "未知的压缩方法 '$CONF_COMPRESSION_METHOD'.";;
    esac

    if [[ "${CONF_PARALLEL_JOBS:-1}" -gt 1 ]]; then
        if command -v parallel &>/dev/null; then
            PARALLEL_CMD="parallel --no-notice --jobs $CONF_PARALLEL_JOBS --halt soon,fail=1"
            log_msg INFO "找到 GNU Parallel。将尝试使用 $CONF_PARALLEL_JOBS 个并行任务。"
        else
            log_msg WARN "未找到 GNU Parallel，但 CONF_PARALLEL_JOBS ($CONF_PARALLEL_JOBS) > 1。将回退到串行执行。"
            CONF_PARALLEL_JOBS=1; PARALLEL_CMD=""
        fi
    else
        CONF_PARALLEL_JOBS=1; PARALLEL_CMD=""
        log_msg INFO "将使用串行方式执行备份任务 (CONF_PARALLEL_JOBS: $CONF_PARALLEL_JOBS)。"
    fi
    log_msg INFO "配置文件加载和初始化完成。"
}

################################################################################
# 检查指定路径上的可用磁盘空间百分比。
# Globals:
#   None
# Arguments:
#   $1 - 需要检查磁盘空间的路径。
#   $2 - 要求的最小剩余磁盘空间百分比。
# Returns:
#   0 如果磁盘空间充足。
#   脚本会以状态码 1 退出，如果磁盘空间不足。
#   如果无法获取磁盘空间信息，则记录警告并返回 0 (跳过检查)。
################################################################################
check_disk_space() {
    local path_to_check="$1"
    local required_percent="$2"
    local available_space_used_percent
    log_msg INFO "检查路径 '$path_to_check' 的可用磁盘空间 (要求最小剩余 ${required_percent}%)..."
    if ! available_space_used_percent=$(df --output=pcent "$path_to_check" 2>/dev/null | tail -n 1 | sed 's/%//' | xargs); then
        log_msg WARN "无法获取路径 '$path_to_check' 的磁盘使用百分比。跳过磁盘空间检查。"
        return 0
    fi
    local free_space_percent=$((100 - available_space_used_percent))

    if [[ "$free_space_percent" -lt "$required_percent" ]]; then
        log_msg ERROR "路径 '$path_to_check' 磁盘空间不足。可用: ${free_space_percent}%, 要求: ${required_percent}%。"
        exit 1
    else
        log_msg INFO "路径 '$path_to_check' 磁盘空间检查通过。可用: ${free_space_percent}% (要求: ${required_percent}% 剩余)。"
    fi
}

################################################################################
# 执行通用的 rsync 备份操作。
# 此函数被其他特定备份任务函数调用。
# Globals:
#   BACKUP_TARGET_DIR_UNCOMPRESSED (R) - 未压缩备份的根目录。
#   CURRENT_TIMESTAMP              (R) - 当前备份的时间戳。
#   CONF_USER_HOME_EXCLUDE         (R) - 用户家目录的排除列表 (如果 task_name 是 "用户数据")。
#   CONF_CUSTOM_PATHS_EXCLUDE      (R) - 自定义路径的排除列表 (如果 task_name 是 "自定义路径")。
#   SCRIPT_NAME                    (R) - 用于生成临时文件名。
# Arguments:
#   $1 - 备份任务的描述性名称 (用于日志)。
#   $2 - 在当前时间戳目录下创建的目标子目录名称 (如 "etc", "home_USER")。
#   $3 - rsync 的 --link-dest 选项字符串 (如果启用增量备份) 或空字符串。
#   $@ - (从第四个参数开始) 一个或多个要备份的源文件/目录路径。
# Returns:
#   0 如果 rsync 成功完成。
#   rsync 的退出码如果失败。
################################################################################
_perform_rsync_backup() {
    local task_name="$1"
    local dest_subdir_name="$2"
    local link_dest_opt="$3"
    shift 3
    local sources_array=("$@")
    local rsync_dest_path="${BACKUP_TARGET_DIR_UNCOMPRESSED}/${CURRENT_TIMESTAMP}/${dest_subdir_name}/"

    mkdir -p "$rsync_dest_path"
    log_msg DEBUG "为任务 '$task_name' 创建目标子目录: $rsync_dest_path"

    local rsync_opts_array=(
        "-aH" "--delete" "--numeric-ids" "--info=progress2"
    )
    [[ -n "$link_dest_opt" ]] && rsync_opts_array+=("$link_dest_opt")

    log_msg INFO "开始执行备份任务: $task_name"
    log_msg DEBUG "源路径 (传递给rsync): ${sources_array[*]}"
    log_msg DEBUG "目标路径: $rsync_dest_path"
    
    local temp_exclude_files=()

    if [[ "$task_name" == "用户数据" && ${#CONF_USER_HOME_EXCLUDE[@]} -gt 0 ]]; then
        local user_exclude_file
        user_exclude_file=$(mktemp "/tmp/${SCRIPT_NAME}_user_exclude.XXXXXX")
        temp_exclude_files+=("$user_exclude_file")
        printf "%s\n" "${CONF_USER_HOME_EXCLUDE[@]}" > "$user_exclude_file"
        rsync_opts_array+=("--exclude-from=$user_exclude_file")
        log_msg DEBUG "为 '$task_name' 创建了用户排除文件: $user_exclude_file 内容: $(cat "$user_exclude_file" | tr '\n' ' ')"
    fi
    
    if [[ "$task_name" == "自定义路径" && ${#CONF_CUSTOM_PATHS_EXCLUDE[@]} -gt 0 ]]; then
        local custom_exclude_file
        custom_exclude_file=$(mktemp "/tmp/${SCRIPT_NAME}_custom_exclude.XXXXXX")
        temp_exclude_files+=("$custom_exclude_file")
        printf "%s\n" "${CONF_CUSTOM_PATHS_EXCLUDE[@]}" > "$custom_exclude_file"
        rsync_opts_array+=("--exclude-from=$custom_exclude_file")
        log_msg DEBUG "为 '$task_name' 创建了自定义排除文件: $custom_exclude_file 内容: $(cat "$custom_exclude_file" | tr '\n' ' ')"
    fi

    if [[ ${#sources_array[@]} -eq 0 ]]; then
        log_msg WARN "任务 '$task_name': 没有有效的源路径可供备份 (可能已被预先过滤)。"
        for tmp_file in "${temp_exclude_files[@]}"; do rm -f "$tmp_file"; done
        return 0
    fi

    log_msg DEBUG "执行 rsync 命令: rsync ${rsync_opts_array[*]} ${sources_array[*]} $rsync_dest_path"
    if rsync "${rsync_opts_array[@]}" "${sources_array[@]}" "$rsync_dest_path"; then
        log_msg INFO "成功完成备份任务: $task_name"
    else
        local rsync_exit_code=$?
        log_msg ERROR "备份任务失败: $task_name (rsync 退出码: $rsync_exit_code)"
        for tmp_file in "${temp_exclude_files[@]}"; do rm -f "$tmp_file"; done
        return "$rsync_exit_code"
    fi

    for tmp_file in "${temp_exclude_files[@]}"; do
        rm -f "$tmp_file"
        log_msg DEBUG "已删除临时排除文件: $tmp_file"
    done
    return 0
}

################################################################################
# 备份系统配置文件 (通常是 /etc)。
# Globals:
#   CONF_BACKUP_SYSTEM_CONFIG (R) - 是否启用此备份类别。
#   EFFECTIVE_UID             (R) - 当前脚本的有效用户ID。
# Arguments:
#   $1 - (传递给 _perform_rsync_backup) rsync 的 --link-dest 选项。
# Returns:
#   0 如果成功或跳过。
#   1 如果因权限问题而跳过或 _perform_rsync_backup 失败。
################################################################################
backup_system_config() {
    if [[ "$CONF_BACKUP_SYSTEM_CONFIG" != "true" ]]; then log_msg INFO "[系统配置] 跳过备份 (未启用)。"; return 0; fi
    log_msg INFO "[系统配置] 开始处理系统配置文件备份..."
    if [[ "$EFFECTIVE_UID" -ne 0 ]]; then
        log_msg WARN "[系统配置] 跳过备份: 备份 /etc 需要 root 权限。"
        return 1
    fi
    log_msg DEBUG "[系统配置] 源路径: /etc/"
    _perform_rsync_backup "系统配置 (/etc)" "etc" "$1" "/etc/"
}

################################################################################
# 备份目标用户的家目录中的选定文件和数据。
# Globals:
#   CONF_BACKUP_USER_DATA    (R) - 是否启用此备份类别。
#   TARGET_BACKUP_USER       (R) - 目标用户名。
#   TARGET_BACKUP_HOME       (R) - 目标用户家目录。
#   CONF_USER_HOME_INCLUDE   (R) - 要包含在家目录备份中的项目列表。
# Arguments:
#   $1 - (传递给 _perform_rsync_backup) rsync 的 --link-dest 选项。
# Returns:
#   0 如果成功、跳过或没有有效源。
#   如果 _perform_rsync_backup 失败则返回其退出码。
################################################################################
backup_user_data() {
    if [[ "$CONF_BACKUP_USER_DATA" != "true" ]]; then log_msg INFO "[用户数据] 跳过备份 (未启用)。"; return 0; fi
    if [[ -z "$TARGET_BACKUP_HOME" ]]; then
        log_msg WARN "[用户数据] 跳过备份: 无法确定有效的用户家目录 (TARGET_BACKUP_HOME 未设置)。"
        return 0
    fi
    log_msg INFO "[用户数据] 开始处理用户 '${TARGET_BACKUP_USER}' (家目录: ${TARGET_BACKUP_HOME}) 的数据备份..."

    local valid_user_sources=()
    log_msg DEBUG "[用户数据] 配置文件中指定的包含项 (相对于家目录 '${TARGET_BACKUP_HOME}'): ${CONF_USER_HOME_INCLUDE[*]}"
    for item in "${CONF_USER_HOME_INCLUDE[@]}"; do
        local full_path="${TARGET_BACKUP_HOME}/${item}"
        if [[ -e "$full_path" ]]; then
            valid_user_sources+=("$full_path")
            log_msg DEBUG "[用户数据] 有效源 (存在): $full_path"
        else
            log_msg WARN "[用户数据] 源路径 '$full_path' 不存在，将跳过此项。"
        fi
    done

    if [[ ${#valid_user_sources[@]} -eq 0 ]]; then
        log_msg WARN "[用户数据] 跳过备份: CONF_USER_HOME_INCLUDE 中未找到任何实际存在的项目。"
        return 0
    fi
    log_msg INFO "[用户数据] 将备份以下有效源 (${#valid_user_sources[@]} 个): ${valid_user_sources[*]}"
    _perform_rsync_backup "用户数据" "home_${TARGET_BACKUP_USER}" "$1" "${valid_user_sources[@]}"
}

################################################################################
# 备份已安装的软件包列表。
# Globals:
#   CONF_BACKUP_PACKAGES             (R) - 是否启用此备份类别。
#   BACKUP_TARGET_DIR_UNCOMPRESSED (R)
#   CURRENT_TIMESTAMP              (R)
# Arguments:
#   None
# Returns:
#   0 总是成功 (除非 pacman 命令严重失败，但这通常不会中止脚本)。
################################################################################
backup_packages() {
    if [[ "$CONF_BACKUP_PACKAGES" != "true" ]]; then log_msg INFO "[软件包列表] 跳过备份 (未启用)。"; return 0; fi
    log_msg INFO "[软件包列表] 开始备份已安装的软件包列表..."
    local pkg_dest_dir="${BACKUP_TARGET_DIR_UNCOMPRESSED}/${CURRENT_TIMESTAMP}/packages/"
    mkdir -p "$pkg_dest_dir"

    local official_list="${pkg_dest_dir}/packages_official.list"
    local aur_foreign_list="${pkg_dest_dir}/packages_aur_foreign.list"
    local all_versions_list="${pkg_dest_dir}/packages_all_versions.list"
    local official_count aur_foreign_count all_versions_count

    if pacman -Qqe > "$official_list"; then
        official_count=$(wc -l < "$official_list" | awk '{print $1}')
        log_msg DEBUG "[软件包列表] 官方包列表已保存至 $official_list ($official_count 个包)"
    else
        log_msg WARN "[软件包列表] 获取官方包列表失败。"
    fi

    if pacman -Qqm > "$aur_foreign_list"; then
        aur_foreign_count=$(wc -l < "$aur_foreign_list" | awk '{print $1}')
        log_msg DEBUG "[软件包列表] AUR/非官方包列表已保存至 $aur_foreign_list ($aur_foreign_count 个包)"
    else
        log_msg WARN "[软件包列表] 获取AUR/非官方包列表失败。"
    fi
    
    if pacman -Q > "$all_versions_list"; then
        all_versions_count=$(wc -l < "$all_versions_list" | awk '{print $1}')
        log_msg DEBUG "[软件包列表] 所有包带版本信息列表已保存至 $all_versions_list ($all_versions_count 个条目)"
    else
        log_msg WARN "[软件包列表] 获取所有包带版本信息列表失败。"
    fi

    log_msg INFO "[软件包列表] 备份完成，存放于 $pkg_dest_dir"
    return 0
}

################################################################################
# 备份系统日志 (journalctl 输出和 /var/log 下的指定文件)。
# Globals:
#   CONF_BACKUP_LOGS                 (R) - 是否启用此备份类别。
#   CONF_BACKUP_JOURNALCTL           (R) - 是否备份 journalctl。
#   CONF_JOURNALCTL_ARGS             (R) - journalctl 的参数。
#   CONF_SYSTEM_LOG_FILES            (R) - /var/log 下要备份的文件列表。
#   BACKUP_TARGET_DIR_UNCOMPRESSED (R)
#   CURRENT_TIMESTAMP              (R)
#   EFFECTIVE_UID                  (R)
# Arguments:
#   None
# Returns:
#   0 总是成功 (日志备份中的错误通常视为非关键)。
################################################################################
backup_logs() {
    if [[ "$CONF_BACKUP_LOGS" != "true" ]]; then log_msg INFO "[系统日志] 跳过备份 (未启用)。"; return 0; fi
    log_msg INFO "[系统日志] 开始备份系统日志..."
    local logs_dest_dir="${BACKUP_TARGET_DIR_UNCOMPRESSED}/${CURRENT_TIMESTAMP}/logs/"
    mkdir -p "$logs_dest_dir"

    if [[ "$CONF_BACKUP_JOURNALCTL" == "true" ]]; then
        local journal_log_file="${logs_dest_dir}/journal.log"
        log_msg DEBUG "[系统日志] 尝试备份 journalctl (参数: ${CONF_JOURNALCTL_ARGS:-<无>}) 至 $journal_log_file"
        if [[ "$EFFECTIVE_UID" -ne 0 ]]; then
            log_msg WARN "[系统日志] 备份 journalctl 可能需要 root 权限以获取完整日志。"
        fi
        # shellcheck disable=SC2086
        if journalctl ${CONF_JOURNALCTL_ARGS} > "$journal_log_file"; then
            log_msg DEBUG "[系统日志] journalctl 输出已保存 (大小: $(du -sh "$journal_log_file" | cut -f1))."
        else
            log_msg WARN "[系统日志] 备份 journalctl 失败 (非关键错误)。"
        fi
    fi

    if [[ ${#CONF_SYSTEM_LOG_FILES[@]} -gt 0 ]]; then
        log_msg DEBUG "[系统日志] 配置文件中指定的系统日志文件/目录: ${CONF_SYSTEM_LOG_FILES[*]}"
        if [[ "$EFFECTIVE_UID" -ne 0 ]]; then
             log_msg WARN "[系统日志] 备份 /var/log/* 下的文件需要 root 权限，当前非 root 用户，将跳过这些文件。"
        else
            for log_file_item in "${CONF_SYSTEM_LOG_FILES[@]}"; do
                local source_log_path="/var/log/${log_file_item}"
                if [[ -e "$source_log_path" ]]; then
                    log_msg DEBUG "[系统日志] 尝试复制 $source_log_path 至 $logs_dest_dir"
                    if cp -aL "$source_log_path" "${logs_dest_dir}/"; then
                         log_msg DEBUG "[系统日志] 已复制 $log_file_item."
                    else
                         log_msg WARN "[系统日志] 复制日志 '$source_log_path' 失败 (非关键错误)。"
                    fi
                else
                    log_msg WARN "[系统日志] 日志 '$source_log_path' 未找到。"
                fi
            done
        fi
    fi
    log_msg INFO "[系统日志] 备份完成，存放于 $logs_dest_dir"
    return 0
}

################################################################################
# 备份用户在配置文件中指定的自定义文件或目录路径。
# Globals:
#   CONF_BACKUP_CUSTOM_PATHS (R) - 是否启用此备份类别。
#   CONF_CUSTOM_PATHS_INCLUDE (R) - 要包含的自定义路径列表。
#   EFFECTIVE_UID             (R)
# Arguments:
#   $1 - (传递给 _perform_rsync_backup) rsync 的 --link-dest 选项。
# Returns:
#   0 如果成功、跳过或没有有效源。
#   1 如果某些路径因权限问题无法访问且脚本非 root 运行。
#   如果 _perform_rsync_backup 失败则返回其退出码。
################################################################################
backup_custom_paths() {
    if [[ "$CONF_BACKUP_CUSTOM_PATHS" != "true" ]]; then log_msg INFO "[自定义路径] 跳过备份 (未启用)。"; return 0; fi
    log_msg INFO "[自定义路径] 开始处理自定义路径备份..."

    local valid_custom_sources=()
    local path_access_issue=false
    log_msg DEBUG "[自定义路径] 配置文件中指定的包含项: ${CONF_CUSTOM_PATHS_INCLUDE[*]}"

    for path_item in "${CONF_CUSTOM_PATHS_INCLUDE[@]}"; do
        if [[ ! -e "$path_item" ]]; then
            log_msg WARN "[自定义路径] 源路径 '$path_item' 不存在，将跳过此项。"
            continue
        fi

        local current_path_ok=true
        if [[ ! -r "$path_item" ]]; then
            if [[ "$EFFECTIVE_UID" -ne 0 ]]; then
                if sudo -n true 2>/dev/null && sudo test -r "$path_item"; then
                    log_msg DEBUG "[自定义路径] 源 '$path_item' 在 sudo下可读 (提示: rsync 仍需以 root 权限运行才能备份此路径)。"
                else
                    log_msg WARN "[自定义路径] 源 '$path_item' 不可读 (当前非root，尝试sudo检查失败或未配置)，将跳过此项。"
                    current_path_ok=false
                    path_access_issue=true
                fi
            else 
                log_msg WARN "[自定义路径] 源 '$path_item' 作为 root 也不可读，将跳过此项。"
                current_path_ok=false
                path_access_issue=true
            fi
        fi

        if $current_path_ok; then
            valid_custom_sources+=("$path_item")
            log_msg DEBUG "[自定义路径] 有效源 (存在且可访问性已检查): $path_item"
        fi
    done

    if [[ ${#valid_custom_sources[@]} -eq 0 ]]; then
        log_msg WARN "[自定义路径] 跳过备份: CONF_CUSTOM_PATHS_INCLUDE 中未找到任何实际存在且可访问的项目。"
        return "$([ $path_access_issue == true ] && echo 1 || echo 0)"
    fi
    log_msg INFO "[自定义路径] 将备份以下有效源 (${#valid_custom_sources[@]} 个): ${valid_custom_sources[*]}"
    _perform_rsync_backup "自定义路径" "custom" "$1" "${valid_custom_sources[@]}"
}

################################################################################
# 压缩指定的未压缩备份目录，并在成功和校验后选择性删除原目录。
# Globals:
#   BACKUP_TARGET_DIR_COMPRESSED_ARCHIVES (R) - 压缩归档的存放目录。
#   CONF_COMPRESSION_EXT                  (R) - 压缩文件的扩展名。
#   CONF_COMPRESSION_METHOD               (R) - 压缩方法 (gzip, bzip2, xz)。
#   CONF_COMPRESSION_LEVEL                (R) - 压缩级别。
# Arguments:
#   $1 - 要压缩的未压缩备份目录的完整路径。
# Returns:
#   0 如果压缩和校验成功 (无论原目录是否被删除)。
#   1 如果压缩或校验失败。
################################################################################
compress_and_verify_backup() {
    local uncompressed_dir_path="$1"
    local uncompressed_dir_name
    uncompressed_dir_name=$(basename "$uncompressed_dir_path")
    local archive_path="${BACKUP_TARGET_DIR_COMPRESSED_ARCHIVES}/${uncompressed_dir_name}.${CONF_COMPRESSION_EXT}"

    if [[ ! -d "$uncompressed_dir_path" ]]; then
        log_msg WARN "[压缩] 无法压缩: 未找到未压缩目录 '$uncompressed_dir_path'。"
        return 1
    fi
    if [[ -f "$archive_path" ]]; then
        log_msg INFO "[压缩] 归档文件 '$archive_path' 已存在。跳过对 '$uncompressed_dir_name' 的压缩。"
        return 0
    fi

    log_msg INFO "[压缩] 开始压缩备份: $uncompressed_dir_name 至 $archive_path"
    log_msg DEBUG "[压缩] 使用方法: $CONF_COMPRESSION_METHOD, 级别: ${CONF_COMPRESSION_LEVEL:-默认}"
    
    local tar_opts=""
    local comp_test_cmd_base=""
    local comp_test_cmd_arg=""
    local compress_env_opts=""

    case "$CONF_COMPRESSION_METHOD" in
        gzip)  tar_opts="-czf"; comp_test_cmd_base="gzip"; comp_test_cmd_arg="-t"
               [[ -n "$CONF_COMPRESSION_LEVEL" ]] && compress_env_opts="GZIP=\"-${CONF_COMPRESSION_LEVEL}\"" ;;
        bzip2) tar_opts="-cjf"; comp_test_cmd_base="bzip2"; comp_test_cmd_arg="-t"
               [[ -n "$CONF_COMPRESSION_LEVEL" ]] && compress_env_opts="BZIP2=\"-${CONF_COMPRESSION_LEVEL}\"" ;;
        xz)    tar_opts="-cJf"; comp_test_cmd_base="xz"; comp_test_cmd_arg="-t"
               [[ -n "$CONF_COMPRESSION_LEVEL" ]] && compress_env_opts="XZ_OPT=\"-${CONF_COMPRESSION_LEVEL} -T0\"" ;;
        *) log_msg ERROR "[压缩] 不支持的压缩方法: $CONF_COMPRESSION_METHOD"; return 1 ;;
    esac
    
    log_msg DEBUG "[压缩] Tar 命令选项: $tar_opts"
    log_msg DEBUG "[压缩] 压缩环境变量 (如果适用): $compress_env_opts"
    log_msg DEBUG "[压缩] 校验命令原型: $comp_test_cmd_base $comp_test_cmd_arg <archive_file>"

    local start_compress_time=$(date +%s)
    if (cd "$(dirname "$uncompressed_dir_path")" && eval "$compress_env_opts tar '$tar_opts' '$archive_path' '$uncompressed_dir_name'"); then
        local end_compress_time=$(date +%s)
        local compress_duration=$((end_compress_time - start_compress_time))
        log_msg INFO "[压缩] 成功压缩: $uncompressed_dir_name (耗时: ${compress_duration}s)"

        log_msg INFO "[压缩] 开始校验归档文件: $archive_path (使用: $comp_test_cmd_base $comp_test_cmd_arg)"
        if "$comp_test_cmd_base" "$comp_test_cmd_arg" "$archive_path"; then
            log_msg INFO "[压缩] 归档 '$archive_path' 校验成功。"
            local archive_size=$(du -sh "$archive_path" | cut -f1)
            log_msg INFO "[压缩] 归档文件大小: $archive_size"
            if confirm_action "压缩成功后是否删除未压缩目录 '$uncompressed_dir_path'？"; then
                log_msg INFO "[压缩] 准备删除未压缩目录: $uncompressed_dir_path"
                rm -rf "$uncompressed_dir_path"
                log_msg INFO "[压缩] 已删除未压缩目录。"
            else
                log_msg INFO "[压缩] 用户选择保留未压缩目录: $uncompressed_dir_path"
            fi
        else
            log_msg ERROR "[压缩] 归档校验失败: '$archive_path'！将保留未压缩目录并删除损坏的归档。"
            rm -f "$archive_path"
            return 1
        fi
    else
        log_msg ERROR "[压缩] 压缩过程失败: '$uncompressed_dir_name'。"
        rm -f "$archive_path"
        return 1
    fi
    return 0
}

################################################################################
# 清理旧的备份，包括压缩超期的未压缩快照和删除超期的压缩归档。
# Globals:
#   CONF_RETENTION_UNCOMPRESSED_COUNT   (R) - 保留的未压缩快照数量。
#   CONF_COMPRESSION_ENABLE             (R) - 是否启用压缩。
#   CONF_RETENTION_COMPRESSED_DAYS      (R) - 压缩归档按天数保留的策略。
#   CONF_RETENTION_COMPRESSED_COUNT     (R) - 压缩归档按数量保留的策略。
#   BACKUP_TARGET_DIR_UNCOMPRESSED    (R)
#   BACKUP_TARGET_DIR_COMPRESSED_ARCHIVES (R)
#   CONF_COMPRESSION_EXT                (R)
# Arguments:
#   None
# Returns:
#   0 (总是，清理过程中的错误被记录但不中止脚本)。
################################################################################
cleanup_backups() {
    log_msg INFO "[清理] 开始执行备份清理流程..."
    local uncompressed_processed_count=0
    local compressed_deleted_count=0

    # 1. 清理未压缩的快照
    if [[ "${CONF_RETENTION_UNCOMPRESSED_COUNT:-0}" -gt 0 ]]; then
        log_msg INFO "[清理/未压缩] 策略: 保留最近 $CONF_RETENTION_UNCOMPRESSED_COUNT 个未压缩快照。"
        local uncompressed_snapshots_list
        uncompressed_snapshots_list=$(find "$BACKUP_TARGET_DIR_UNCOMPRESSED" -mindepth 1 -maxdepth 1 -type d -printf "%T@ %p\n" | sort -nr)
        
        local count=0
        local snapshots_to_process_for_cleanup=()
        log_msg DEBUG "[清理/未压缩] 找到的未压缩快照 (按新旧排序):"
        while IFS= read -r line; do
            [[ -z "$line" ]] && continue
            local snap_path_seconds snap_path_name
            snap_path_seconds=$(echo "$line" | cut -d' ' -f1)
            snap_path_name=$(echo "$line" | cut -d' ' -f2-)
            log_msg DEBUG "[清理/未压缩]   - $(date -d "@$snap_path_seconds" "+%Y-%m-%d %H:%M:%S") - $snap_path_name"
            count=$((count + 1))
            if [[ "$count" -gt "$CONF_RETENTION_UNCOMPRESSED_COUNT" ]]; then
                snapshots_to_process_for_cleanup+=("$snap_path_name")
            fi
        done <<< "$uncompressed_snapshots_list"

        if [[ ${#snapshots_to_process_for_cleanup[@]} -gt 0 ]]; then
            log_msg INFO "[清理/未压缩] 将处理 ${#snapshots_to_process_for_cleanup[@]} 个超出保留数量的未压缩快照。"
            for snap_path_to_process in "${snapshots_to_process_for_cleanup[@]}"; do
                log_msg INFO "[清理/未压缩] 处理快照: $snap_path_to_process"
                
                if [[ "$CONF_COMPRESSION_ENABLE" == "true" ]]; then
                    # 压缩已启用
                    local archive_name_base compressed_archive_path
                    archive_name_base=$(basename "$snap_path_to_process")
                    compressed_archive_path="${BACKUP_TARGET_DIR_COMPRESSED_ARCHIVES}/${archive_name_base}.${CONF_COMPRESSION_EXT}"

                    if [[ -f "$compressed_archive_path" ]]; then
                        # 压缩归档已存在
                        log_msg INFO "[清理/未压缩] 快照 '$snap_path_to_process' 对应的压缩归档 '$compressed_archive_path' 已存在。"
                        if confirm_action "是否删除未压缩快照 '$snap_path_to_process' (因其压缩版已存在)？"; then
                            log_msg INFO "[清理/未压缩] 准备删除 (压缩版已存在): $snap_path_to_process"
                            rm -rf "$snap_path_to_process"
                            log_msg INFO "[清理/未压缩] 已删除: $snap_path_to_process"
                            uncompressed_processed_count=$((uncompressed_processed_count + 1))
                        else
                            log_msg INFO "[清理/未压缩] 用户选择保留 '$snap_path_to_process' (即使压缩版已存在)。"
                        fi
                    else
                        # 压缩归档不存在，尝试压缩
                        log_msg INFO "[清理/未压缩] 尝试压缩 '$snap_path_to_process' (因为其压缩归档 '$compressed_archive_path' 不存在)。"
                        if compress_and_verify_backup "$snap_path_to_process"; then
                            # compress_and_verify_backup 成功后会删除原快照
                            uncompressed_processed_count=$((uncompressed_processed_count + 1))
                        else
                            log_msg WARN "[清理/未压缩] 压缩快照 '$snap_path_to_process' 失败，将保留此未压缩快照。"
                        fi
                    fi
                else
                    # 压缩功能未启用
                    log_msg INFO "[清理/未压缩] 压缩功能已禁用。"
                    if confirm_action "是否永久删除旧的未压缩快照 '$snap_path_to_process' (因压缩功能禁用)？"; then
                        log_msg INFO "[清理/未压缩] 准备删除 (压缩禁用): $snap_path_to_process"
                        rm -rf "$snap_path_to_process"
                        log_msg INFO "[清理/未压缩] 已删除: $snap_path_to_process"
                        uncompressed_processed_count=$((uncompressed_processed_count + 1))
                    else
                        log_msg INFO "[清理/未压缩] 用户选择保留 '$snap_path_to_process' (压缩功能禁用)。"
                    fi
                fi # End of CONF_COMPRESSION_ENABLE check
            done
        else
            log_msg INFO "[清理/未压缩] 没有超出保留数量的未压缩快照需要处理。"
        fi
    else
        log_msg INFO "[清理/未压缩] 跳过清理 (CONF_RETENTION_UNCOMPRESSED_COUNT <= 0)。"
    fi

    # 2. 清理已压缩的归档文件
    log_msg INFO "[清理/压缩] 开始清理已压缩的归档文件..."
    local archives_to_delete_final=()

    if [[ "${CONF_RETENTION_COMPRESSED_DAYS:-0}" -gt 0 ]]; then
        log_msg INFO "[清理/压缩/按时间] 策略: 删除早于 $CONF_RETENTION_COMPRESSED_DAYS 天的归档。"
        local days_for_find_comp=$((CONF_RETENTION_COMPRESSED_DAYS - 1))
        [[ $days_for_find_comp -lt 0 ]] && days_for_find_comp=0
        
        log_msg DEBUG "[清理/压缩/按时间] 使用 find -mtime +$days_for_find_comp"
        while IFS= read -r archive_file_by_age; do
            [[ -z "$archive_file_by_age" ]] && continue
            archives_to_delete_final+=("$archive_file_by_age")
            log_msg DEBUG "[清理/压缩/按时间] 标记删除: $archive_file_by_age (修改时间: $(date -r "$archive_file_by_age" "+%Y-%m-%d %H:%M:%S"))"
        done < <(find "$BACKUP_TARGET_DIR_COMPRESSED_ARCHIVES" -maxdepth 1 -type f -name "*.${CONF_COMPRESSION_EXT}" -mtime "+${days_for_find_comp}")
    else
        log_msg INFO "[清理/压缩/按时间] 跳过按时间清理 (CONF_RETENTION_COMPRESSED_DAYS <= 0)。"
    fi

    if [[ "${CONF_RETENTION_COMPRESSED_COUNT:-0}" -gt 0 ]]; then
        log_msg INFO "[清理/压缩/按数量] 策略: 保留最多 $CONF_RETENTION_COMPRESSED_COUNT 个归档。"
        local current_archives_sorted_list
        current_archives_sorted_list=$(find "$BACKUP_TARGET_DIR_COMPRESSED_ARCHIVES" -maxdepth 1 -type f -name "*.${CONF_COMPRESSION_EXT}" -printf "%T@ %p\n" | sort -n)
        
        local archives_not_yet_marked_for_deletion=()
        log_msg DEBUG "[清理/压缩/按数量] 找到的压缩归档 (按旧新排序):"
        while IFS= read -r line; do
            [[ -z "$line" ]] && continue
            local arc_path_seconds arc_path_name
            arc_path_seconds=$(echo "$line" | cut -d' ' -f1)
            arc_path_name=$(echo "$line" | cut -d' ' -f2-)
            log_msg DEBUG "[清理/压缩/按数量]   - $(date -d "@$arc_path_seconds" "+%Y-%m-%d %H:%M:%S") - $arc_path_name"

            local already_marked_by_age=false
            for marked_arc in "${archives_to_delete_final[@]}"; do
                if [[ "$marked_arc" == "$arc_path_name" ]]; then
                    already_marked_by_age=true; break
                fi
            done
            if ! $already_marked_by_age; then
                archives_not_yet_marked_for_deletion+=("$arc_path_name")
            fi
        done <<< "$current_archives_sorted_list"

        local num_to_delete_for_count=0
        num_to_delete_for_count=$((${#archives_not_yet_marked_for_deletion[@]} - CONF_RETENTION_COMPRESSED_COUNT))

        if [[ "$num_to_delete_for_count" -gt 0 ]]; then
            log_msg INFO "[清理/压缩/按数量] 需要额外删除 $num_to_delete_for_count 个最旧的归档以满足数量限制。"
            for ((i=0; i<num_to_delete_for_count; i++)); do
                archives_to_delete_final+=("${archives_not_yet_marked_for_deletion[i]}")
                log_msg DEBUG "[清理/压缩/按数量] 标记删除: ${archives_not_yet_marked_for_deletion[i]}"
            done
        else
            log_msg INFO "[清理/压缩/按数量] 当前归档数量 (${#archives_not_yet_marked_for_deletion[@]}) 未超出限制 ($CONF_RETENTION_COMPRESSED_COUNT)，无需按数量删除。"
        fi
    else
        log_msg INFO "[清理/压缩/按数量] 跳过按数量清理 (CONF_RETENTION_COMPRESSED_COUNT <= 0)。"
    fi
    
    local unique_archives_to_delete_final_list
    if [[ ${#archives_to_delete_final[@]} -gt 0 ]]; then
        unique_archives_to_delete_final_list=$(printf "%s\n" "${archives_to_delete_final[@]}" | sort -u)
    else
        unique_archives_to_delete_final_list=""
    fi

    if [[ -z "$unique_archives_to_delete_final_list" ]]; then
        log_msg INFO "[清理/压缩] 没有标记为待删除的压缩归档。"
    else
        local num_unique_to_delete_comp
        num_unique_to_delete_comp=$(echo "$unique_archives_to_delete_final_list" | wc -l)
        log_msg INFO "[清理/压缩] 以下 $num_unique_to_delete_comp 个压缩归档将被删除:"
        local f_idx
        mapfile -t f_array < <(echo "$unique_archives_to_delete_final_list")
        for f_idx in "${!f_array[@]}"; do
            log_msg INFO "[清理/压缩]   - ${f_array[$f_idx]}"
        done

        if confirm_action "是否继续删除这 $num_unique_to_delete_comp 个压缩归档文件？"; then
            mapfile -t f_del_array < <(echo "$unique_archives_to_delete_final_list")
            for archive_to_delete in "${f_del_array[@]}"; do
                [[ -z "$archive_to_delete" ]] && continue
                log_msg INFO "[清理/压缩] 准备删除已标记的压缩归档: $archive_to_delete"
                if rm -f "$archive_to_delete"; then
                    compressed_deleted_count=$((compressed_deleted_count + 1))
                    log_msg INFO "[清理/压缩] 已删除: $archive_to_delete"
                else
                    log_msg WARN "[清理/压缩] 删除 '$archive_to_delete' 失败。"
                fi
            done
        else
            log_msg INFO "[清理/压缩] 用户取消了旧压缩归档的删除操作。"
        fi
    fi

    log_msg INFO "[清理] 清理流程结束。共处理了(压缩或删除) $uncompressed_processed_count 个未压缩快照，删除了 $compressed_deleted_count 个压缩归档。"
    return 0
}

################################################################################
# 主备份流程编排函数。
# 负责初始化备份、执行各项备份任务 (串行或并行)、以及后续的清理工作。
# Globals:
#   (许多 CONF_* 和运行时变量)
# Arguments:
#   None
# Returns:
#   0 如果整个备份和清理流程成功。
#   1 如果流程中发生任何关键错误。
################################################################################
run_backup() {
    local backup_start_time
    backup_start_time=$(date +%s)

    log_msg INFO "===== 开始 Arch Linux 备份流程 (版本 $SCRIPT_VERSION) ====="
    CURRENT_TIMESTAMP=$(date '+%Y%m%d_%H%M%S')
    local current_backup_path_uncompressed="${BACKUP_TARGET_DIR_UNCOMPRESSED}/${CURRENT_TIMESTAMP}"
    mkdir -p "$current_backup_path_uncompressed"
    log_msg INFO "当前备份时间戳: $CURRENT_TIMESTAMP"
    log_msg INFO "当前备份目标 (未压缩): $current_backup_path_uncompressed"
    log_msg DEBUG "备份根目录: $CONF_BACKUP_ROOT_DIR"
    log_msg DEBUG "未压缩快照存放目录: $BACKUP_TARGET_DIR_UNCOMPRESSED"
    log_msg DEBUG "压缩归档存放目录: $BACKUP_TARGET_DIR_COMPRESSED_ARCHIVES"

    check_disk_space "$CONF_BACKUP_ROOT_DIR" "$CONF_MIN_FREE_DISK_SPACE_PERCENT"

    local link_dest_option=""
    if [[ "$CONF_INCREMENTAL_BACKUP" == "true" ]]; then
        log_msg INFO "增量备份已启用，正在查找上一个快照..."
        local latest_snapshot_dir
        latest_snapshot_dir=$(find "$BACKUP_TARGET_DIR_UNCOMPRESSED" -mindepth 1 -maxdepth 1 -type d ! -name "$CURRENT_TIMESTAMP" -printf "%T@ %p\n" | sort -nr | head -n 1 | cut -d' ' -f2-)

        if [[ -n "$latest_snapshot_dir" && -d "$latest_snapshot_dir" ]]; then
            local relative_link_dest="../$(basename "$latest_snapshot_dir")"
            if [[ -d "${BACKUP_TARGET_DIR_UNCOMPRESSED}/$(basename "$latest_snapshot_dir")" ]]; then
                link_dest_option="--link-dest=${relative_link_dest}"
                log_msg INFO "找到上一个快照: '$(basename "$latest_snapshot_dir")'。将使用 --link-dest='$relative_link_dest' 进行增量备份。"
            else
                log_msg WARN "找到的上一个快照目录 '$(basename "$latest_snapshot_dir")' 似乎不再存在于 '$BACKUP_TARGET_DIR_UNCOMPRESSED/'. 本次将作为新的完整备份基线。"
                link_dest_option=""
            fi
        else
            log_msg INFO "未找到上一个有效快照。本次将作为新的完整备份基线。"
            link_dest_option=""
        fi
    else
        log_msg INFO "增量备份已禁用。本次将执行完整备份。"
        link_dest_option=""
    fi

    local backup_tasks=()
    [[ "$CONF_BACKUP_SYSTEM_CONFIG" == "true" ]] && backup_tasks+=("backup_system_config \"$link_dest_option\"")
    [[ "$CONF_BACKUP_USER_DATA" == "true" ]] && backup_tasks+=("backup_user_data \"$link_dest_option\"")
    [[ "$CONF_BACKUP_PACKAGES" == "true" ]] && backup_tasks+=("backup_packages")
    [[ "$CONF_BACKUP_LOGS" == "true" ]] && backup_tasks+=("backup_logs")
    [[ "$CONF_BACKUP_CUSTOM_PATHS" == "true" ]] && backup_tasks+=("backup_custom_paths \"$link_dest_option\"")

    if [[ ${#backup_tasks[@]} -eq 0 ]]; then
        log_msg WARN "没有启用的备份类别。备份流程中止。"
        rm -rf "$current_backup_path_uncompressed"
        return 0
    fi
    log_msg INFO "将要执行的备份任务 (${#backup_tasks[@]} 个):"
    for task_desc in "${backup_tasks[@]}"; do log_msg INFO "  - ${task_desc%% \"*\"}"; done

    local overall_backup_success="true"
    local task_execution_summary=()

    if [[ "$CONF_PARALLEL_JOBS" -gt 1 && -n "$PARALLEL_CMD" ]]; then
        log_msg INFO "使用 GNU Parallel (${CONF_PARALLEL_JOBS}个作业) 并行执行备份任务..."
        export SCRIPT_NAME SCRIPT_DIR CURRENT_TIMESTAMP BACKUP_TARGET_DIR_UNCOMPRESSED CONF_BACKUP_ROOT_DIR CONF_LOG_FILE CONF_LOG_LEVEL CURRENT_LOG_LEVEL
        export CONF_USER_HOME_INCLUDE CONF_USER_HOME_EXCLUDE CONF_CUSTOM_PATHS_INCLUDE CONF_CUSTOM_PATHS_EXCLUDE TARGET_BACKUP_HOME TARGET_BACKUP_USER
        export CONF_BACKUP_JOURNALCTL CONF_JOURNALCTL_ARGS CONF_SYSTEM_LOG_FILES EFFECTIVE_UID CONF_PROMPT_FOR_CONFIRMATION
        export LOG_LEVEL_DEBUG LOG_LEVEL_INFO LOG_LEVEL_WARN LOG_LEVEL_ERROR LOG_LEVEL_NAMES
        export COLOR_RESET COLOR_RED COLOR_GREEN COLOR_YELLOW COLOR_BLUE COLOR_CYAN
        export -f backup_system_config backup_user_data backup_packages backup_logs backup_custom_paths _perform_rsync_backup log_msg confirm_action
        
        local parallel_input=""
        for task_cmd_str in "${backup_tasks[@]}"; do
             parallel_input+="${task_cmd_str}\n"
        done
        
        log_msg DEBUG "传递给 GNU Parallel 的任务列表:\n$parallel_input"
        if ! printf "%b" "$parallel_input" | $PARALLEL_CMD bash -ce ". \"$SCRIPT_DIR/$SCRIPT_NAME\"; {}"; then
             overall_backup_success="false"
             log_msg ERROR "GNU Parallel 执行返回错误，一个或多个并行备份任务可能失败。请检查上方日志。"
             task_execution_summary+=("并行任务组: 失败 (部分或全部，由 Parallel 报告)")
        else
             log_msg INFO "GNU Parallel 任务组执行完毕 (Parallel 本身未报告错误)。"
             task_execution_summary+=("并行任务组: 完成 (具体子任务状态请查阅其独立日志)")
        fi
    else
        log_msg INFO "串行执行备份任务..."
        local task_num=1
        for task_cmd_str in "${backup_tasks[@]}"; do
            local task_fn_name="${task_cmd_str%% \"*\"}"
            log_msg INFO "--- 开始串行任务 ${task_num}/${#backup_tasks[@]}: ${task_fn_name} ---"
            if eval "$task_cmd_str"; then
                log_msg INFO "--- 串行任务 ${task_num} (${task_fn_name}) 成功 ---"
                task_execution_summary+=("${task_fn_name}: 成功")
            else
                local task_exit_code=$?
                overall_backup_success="false"
                log_msg ERROR "--- 串行任务 ${task_num} (${task_fn_name}) 失败 (退出码: $task_exit_code) ---"
                task_execution_summary+=("${task_fn_name}: 失败 (退出码: $task_exit_code)")
            fi
            task_num=$((task_num + 1))
        done
    fi

    log_msg INFO "所有备份任务执行阶段完成。"
    log_msg INFO "任务执行摘要:"
    for summary_item in "${task_execution_summary[@]}"; do
        log_msg INFO "  - $summary_item"
    done

    if [[ "$overall_backup_success" == "false" ]]; then
        log_msg ERROR "由于一个或多个备份任务失败，当前备份 ($current_backup_path_uncompressed) 可能不完整或存在问题。"
    else
        log_msg INFO "所有核心备份任务均已成功完成或按预期跳过: $CURRENT_TIMESTAMP。"
        local backup_dir_content_check
        backup_dir_content_check=$(find "$current_backup_path_uncompressed" -mindepth 1 -print -quit 2>/dev/null)

        if [[ -z "$backup_dir_content_check" ]]; then
            local any_task_should_produce_output=false
            for summary in "${task_execution_summary[@]}"; do
                if [[ "$summary" == *": 成功"* ]]; then
                    any_task_should_produce_output=true; break
                fi
            done

            if $any_task_should_produce_output ; then
                 log_msg WARN "警告: 备份目录 $current_backup_path_uncompressed 最终为空，但有任务报告成功！这可能表示配置或执行存在严重问题。"
                 overall_backup_success="false"
            else
                 log_msg INFO "所有任务均未产生输出或全部跳过，备份目录为空是正常的。"
                 log_msg INFO "删除空的快照目录: $current_backup_path_uncompressed"
                 rm -rf "$current_backup_path_uncompressed" 2>/dev/null
            fi
        else
            local uncompressed_size
            uncompressed_size=$(du -sh "$current_backup_path_uncompressed" | cut -f1)
            log_msg INFO "当前未压缩备份占用空间: $uncompressed_size"
            log_msg INFO "基本验证: 备份目录 $current_backup_path_uncompressed 非空。"
        fi
    fi

    cleanup_backups

    local backup_end_time=$(date +%s)
    local total_backup_duration=$((backup_end_time - backup_start_time))
    log_msg INFO "整个备份和清理流程总耗时: ${total_backup_duration} 秒。"

    if [[ "$overall_backup_success" == "false" ]]; then
        log_msg ERROR "===== Arch Linux 备份流程结束，但检测到错误 ====="
        return 1
    fi
    log_msg INFO "===== Arch Linux 备份流程成功结束 ====="
    return 0
}

################################################################################
# 脚本的主入口函数。
# 初始化、加载配置、检查依赖、然后调用 run_backup 执行备份流程。
# Globals:
#   (许多)
# Arguments:
#   $@ - 传递给脚本的命令行参数 (当前未使用)。
# Returns:
#   0 如果脚本成功完成。
#   1 如果发生错误。
################################################################################
main() {
    echo "--- $(date '+%Y-%m-%d %H:%M:%S') - $SCRIPT_NAME (PID: $SCRIPT_PID) - 脚本启动 ---" >> "${CONF_LOG_FILE:-/tmp/${SCRIPT_NAME}.log}"

    if [[ "$EFFECTIVE_UID" -ne 0 ]]; then
        echo "警告: 为了完整备份系统文件 (如 /etc) 和正确处理权限，建议使用 'sudo $0' 运行此脚本。" >&2
        log_msg WARN "脚本未使用 root 权限运行。系统级备份功能将受限。"
    fi
    if [[ "$EFFECTIVE_UID" -eq 0 && -z "$SUDO_USER" ]]; then
        log_msg WARN "脚本正以 root 用户直接运行 (非通过sudo)。如果计划进行特定用户数据备份，请在配置文件中设置 CONF_TARGET_USERNAME。"
    fi

    load_config

    log_msg INFO "脚本版本: $SCRIPT_VERSION"
    log_msg INFO "脚本执行路径: $SCRIPT_DIR/$SCRIPT_NAME"
    log_msg INFO "脚本PID: $SCRIPT_PID"
    log_msg INFO "执行用户 (有效): $EFFECTIVE_USER (UID: $EFFECTIVE_UID)"
    if [[ -n "$SUDO_USER" ]]; then
        log_msg INFO "通过 sudo 调用，调用 sudo 的用户 (SUDO_USER): $SUDO_USER (UID: ${SUDO_UID:-N/A}, GID: ${SUDO_GID:-N/A})"
    fi
    log_msg INFO "用于家目录备份的目标用户信息: User='${TARGET_BACKUP_USER:-未指定/无效}', UID='${TARGET_BACKUP_UID:-N/A}', GID='${TARGET_BACKUP_GID:-N/A}', Home='${TARGET_BACKUP_HOME:-N/A}'"
    log_msg INFO "加载的配置文件: ${LOADED_CONFIG_FILE:-未找到，使用默认值}"
    log_msg INFO "当前日志级别设置为: ${LOG_LEVEL_NAMES[$CURRENT_LOG_LEVEL]} ($CURRENT_LOG_LEVEL)"

    local required_system_deps=(
        "rsync" "tar" "find" "sort" "df" "getent" "cut" "head" "tail" "sed" "grep" "wc" "mkdir" "rm" "id" "date" "basename" "dirname" "mktemp" "du" "awk"
    )
    local compression_tool_to_check=""
    case "$CONF_COMPRESSION_METHOD" in
        gzip)  compression_tool_to_check="gzip" ;;
        bzip2) compression_tool_to_check="bzip2" ;;
        xz)    compression_tool_to_check="xz" ;;
    esac
    [[ -n "$compression_tool_to_check" ]] && required_system_deps+=("$compression_tool_to_check")

    if [[ "${CONF_PARALLEL_JOBS:-1}" -gt 1 ]]; then
        required_system_deps+=("parallel")
    fi
    check_dependencies "${required_system_deps[@]}"

    if run_backup; then
        log_msg INFO "$SCRIPT_NAME 执行成功完成。"
    else
        log_msg ERROR "$SCRIPT_NAME 执行过程中遇到一个或多个错误。"
        echo "--- $(date '+%Y-%m-%d %H:%M:%S') - $SCRIPT_NAME (PID: $SCRIPT_PID) - 脚本因错误退出 ---" >> "$CONF_LOG_FILE"
        exit 1
    fi

    echo "--- $(date '+%Y-%m-%d %H:%M:%S') - $SCRIPT_NAME (PID: $SCRIPT_PID) - 脚本正常结束 ---" >> "$CONF_LOG_FILE"
    exit 0
}

################################################################################
# 当脚本接收到 SIGINT 或 SIGTERM 信号时的清理处理函数。
# Globals:
#   CONF_LOG_FILE (R) - 日志文件路径 (可能尚未完全初始化)。
#   SCRIPT_NAME   (R)
#   SCRIPT_PID    (R)
# Arguments:
#   $1 - 接收到的信号名称 (e.g., "SIGINT")。
# Returns:
#   脚本以对应信号的退出码退出 (通常是 128 + 信号编号)。
################################################################################
cleanup_on_signal() {
    local signal_name="$1"
    if typeset -f log_msg &>/dev/null && [[ -n "${CONF_LOG_FILE:-}" && -w "${CONF_LOG_FILE:-/dev/null}" ]]; then
        log_msg WARN "脚本被信号 $signal_name 中断 (PID: $SCRIPT_PID)。"
    else
        echo "$(date '+%Y-%m-%d %H:%M:%S') [WARN] 脚本被信号 $signal_name 中断 (PID: $SCRIPT_PID)。" >> "${CONF_LOG_FILE:-/tmp/${SCRIPT_NAME}.log}"
        echo "脚本被信号 $signal_name 中断。" >&2
    fi
    local exit_code=1
    [[ "$signal_name" == "SIGINT" ]] && exit_code=130
    [[ "$signal_name" == "SIGTERM" ]] && exit_code=143
    exit "$exit_code"
}
trap 'cleanup_on_signal SIGINT' SIGINT
trap 'cleanup_on_signal SIGTERM' SIGTERM

# 执行 main 函数
main "$@"
```
## arch_backup.conf
```bash
# ~/.config/arch_backup.conf
# arch_backup.sh 脚本的配置文件

# === 基本设置 ===
# 备份文件存放的根目录。
# 请确保此目录存在并且有足够的磁盘空间。
CONF_BACKUP_ROOT_DIR="/mnt/backup/archlinux"

# 日志文件路径。
# 如果脚本以 root 身份运行: CONF_LOG_FILE="/var/log/arch_backup.log"
# 如果以普通用户身份运行，或用于用户特定的日志: CONF_LOG_FILE="${HOME}/.cache/arch_backup/arch_backup.log"
CONF_LOG_FILE="/var/log/arch_backup.log"

# 日志级别: DEBUG (调试), INFO (信息), WARN (警告), ERROR (错误)
CONF_LOG_LEVEL="DEBUG"

# ... (其他配置保持不变) ...

# === 用户特定备份设置 ===
# 如果希望备份特定用户的家目录 (而不是执行 sudo 的用户，或者当脚本由 root 的 cron 运行时)，
# 在这里指定用户名。如果留空，脚本将尝试确定原始 sudo 用户。
# 如果脚本以普通用户身份运行 (非 sudo)，则此设置无效，将备份当前用户。
CONF_TARGET_USERNAME="cjz" # 例如: "myuser", 或者留空 ""

# === 备份类别 ===
# 设置为 "true" 启用该类别的备份, "false" 则禁用。
CONF_BACKUP_SYSTEM_CONFIG="true"  # 系统配置文件
CONF_BACKUP_USER_DATA="true"      # 用户家目录数据
CONF_BACKUP_PACKAGES="true"       # 已安装软件包列表
CONF_BACKUP_LOGS="true"           # 系统日志
CONF_BACKUP_CUSTOM_PATHS="true"   # 用户自定义路径

# === 用户数据配置 ===
# 仅当 CONF_BACKUP_USER_DATA="true" 时生效
# 用户家目录下需要备份的项目列表 (空格分隔)。
# 路径相对于用户家目录。
CONF_USER_HOME_INCLUDE=(
    ".config"
    ".local/share"
    # ".ssh"
    # ".gnupg"
    ".bashrc"
    ".zsh_history"
    ".zshrc"
    # "Documents"
    # "Pictures"
    # "Videos" # 示例: 通常较大, 考虑排除
)

# 从用户家目录备份中排除的模式列表 (空格分隔)。
# 这些是 rsync 的排除模式。
CONF_USER_HOME_EXCLUDE=(
    "*/.cache/*"
    "*/Cache/*"
    "*/node_modules/*"
    "*/Trash/*"
    "*.tmp"
    "arch_backup.conf"
    "Downloads/*" # 通常是临时文件
)

# === 自定义路径配置 ===
# 仅当 CONF_BACKUP_CUSTOM_PATHS="true" 时生效
# 需要备份的绝对路径列表 (空格分隔)。
CONF_CUSTOM_PATHS_INCLUDE=(
    # "/opt/my_custom_app"
    # "/srv/http"
)
# 自定义路径的 rsync排除模式列表 (空格分隔)。
# 全局应用于所有自定义路径的包含项。
CONF_CUSTOM_PATHS_EXCLUDE=(
    "*/temp_files/*"
)

# === 系统日志配置 ===
# 仅当 CONF_BACKUP_LOGS="true" 时生效
# /var/log 下的关键日志文件/目录列表 (空格分隔)。
CONF_SYSTEM_LOG_FILES=(
    "pacman.log"
    "Xorg.0.log"
    # "journal" # journalctl 的输出通常更受青睐，并会单独捕获
)
# 是否捕获 journalctl 的输出?
CONF_BACKUP_JOURNALCTL="true"
# journalctl 的参数 (例如: --boot=-1 代表上次启动的日志)
CONF_JOURNALCTL_ARGS="" # 为空则代表当前启动的所有日志, 或例如: "--since yesterday"

# === 备份机制 ===
# 是否启用增量备份 (使用 rsync 的 --link-dest)。
# 如果为 false,每次备份都是完整复制 (消耗更多空间)。
CONF_INCREMENTAL_BACKUP="true"

# 是否为旧备份启用压缩。
CONF_COMPRESSION_ENABLE="true"
# 压缩方法: gzip, bzip2, xz
CONF_COMPRESSION_METHOD="xz"
# 压缩级别 (取决于压缩方法, 例如 gzip/xz 为 1-9, xz 默认为 6)
CONF_COMPRESSION_LEVEL="6"
# 压缩归档文件的扩展名
CONF_COMPRESSION_EXT="tar.xz" # 如果方法改变，这里也要改 (例如 .tar.gz)

# === 保留策略 ===
# 保留最近多少个 *未压缩* 的快照。
# 如果启用了增量备份，这些快照将用于 --link-dest。如果启用增量，则最少为1。
CONF_RETENTION_UNCOMPRESSED_COUNT="3"

# 如何清理 *已压缩* 的归档文件:
# 选项1: 保留特定数量的压缩归档。
CONF_RETENTION_COMPRESSED_COUNT="10" # 设置为 0 禁用基于数量的保留
# 选项2: 删除超过 X 天的压缩归档。
CONF_RETENTION_COMPRESSED_DAYS="90" # 设置为 0 禁用基于时间的保留
# 如果两者都设置，则更严格的那个（保留更少备份）可能会隐式应用，
# 或者脚本可以优先考虑一个（例如，先按时间，然后如果数量仍然超出，则删除最旧的以满足数量）。
# 我们设定优先级：首先按时间删除，然后如果数量仍然超出，则删除最旧的以满足数量限制。

# === 高级功能 ===
# 并行备份任务的数量。
# 如果 > 1, 需要 GNU Parallel。如果找不到 parallel 或值为 1, 则回退到串行执行。
CONF_PARALLEL_JOBS="2" # 设置为 1 表示串行执行。

# === 用户交互 ===
# 在执行有风险的操作前 (例如删除旧备份) 是否提示用户确认。
CONF_PROMPT_FOR_CONFIRMATION="false"

# 备份目标路径上要求的最小剩余磁盘空间百分比。
CONF_MIN_FREE_DISK_SPACE_PERCENT="10"
```
## 完善方案：
由于这个脚本最终会让它定时无感执行，所以要进行如下完善：

1. 错误处理和记录：
利用 trap ERR 捕获未被 set -e 直接终止的命令错误（虽然 set -e 已经很严格了），并记录更详细的错误发生位置。
确保关键操作（如目录创建、文件写入）都有错误检查。
2. 备份验证 (文件清单)：
在每个 rsync 完成的备份子目录（如 etc/, home_user/, custom/）内，生成一个 MANIFEST.txt 文件，包含该目录下所有文件的列表、大小和修改时间戳。
3. 资源使用优化、进度、预估时间：
资源使用： 对 rsync 和 tar | compressor 命令使用 nice 和 ionice（如果可用）。
更清晰的进度： 在日志中明确每个主要步骤的开始和结束，记录耗时。

4. 自动生成配置文件：
脚本启动时，如果检测到常用的配置文件路径都不存在，则为用户是否生成一个默认的配置文件模板到用户家目录的 .config下。
5. 带时间戳的日志：
不再是持续追加到同一个日志文件，而是每次脚本运行时，创建一个新的日志文件，日志名字带有时间戳，日志路径自定义设置
6. 要求
代码风格保持与目前代码一致，请勿不要删除存在代码的注释，除非代码不存在了，这点请时刻牢记，为了实现目标，尽量减小对当前代码的破坏